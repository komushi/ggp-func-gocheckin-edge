import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
import { IoTDataPlaneServiceException as __BaseException } from "./IoTDataPlaneServiceException";
/**
 * <p>The specified version does not match the version of the document.</p>
 */
export declare class ConflictException extends __BaseException {
    readonly name: "ConflictException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
/**
 * <p>The input for the DeleteThingShadow operation.</p>
 */
export interface DeleteThingShadowRequest {
    /**
     * <p>The name of the thing.</p>
     */
    thingName: string | undefined;
    /**
     * <p>The name of the shadow.</p>
     */
    shadowName?: string;
}
export declare namespace DeleteThingShadowRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteThingShadowRequest) => any;
}
/**
 * <p>The output from the DeleteThingShadow operation.</p>
 */
export interface DeleteThingShadowResponse {
    /**
     * <p>The state information, in JSON format.</p>
     */
    payload: Uint8Array | undefined;
}
export declare namespace DeleteThingShadowResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteThingShadowResponse) => any;
}
/**
 * <p>An unexpected error has occurred.</p>
 */
export declare class InternalFailureException extends __BaseException {
    readonly name: "InternalFailureException";
    readonly $fault: "server";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InternalFailureException, __BaseException>);
}
/**
 * <p>The request is not valid.</p>
 */
export declare class InvalidRequestException extends __BaseException {
    readonly name: "InvalidRequestException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>);
}
/**
 * <p>The specified combination of HTTP verb and URI is not supported.</p>
 */
export declare class MethodNotAllowedException extends __BaseException {
    readonly name: "MethodNotAllowedException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<MethodNotAllowedException, __BaseException>);
}
/**
 * <p>The specified resource does not exist.</p>
 */
export declare class ResourceNotFoundException extends __BaseException {
    readonly name: "ResourceNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
}
/**
 * <p>The service is temporarily unavailable.</p>
 */
export declare class ServiceUnavailableException extends __BaseException {
    readonly name: "ServiceUnavailableException";
    readonly $fault: "server";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>);
}
/**
 * <p>The rate exceeds the limit.</p>
 */
export declare class ThrottlingException extends __BaseException {
    readonly name: "ThrottlingException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
}
/**
 * <p>You are not authorized to perform this operation.</p>
 */
export declare class UnauthorizedException extends __BaseException {
    readonly name: "UnauthorizedException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnauthorizedException, __BaseException>);
}
/**
 * <p>The document encoding is not supported.</p>
 */
export declare class UnsupportedDocumentEncodingException extends __BaseException {
    readonly name: "UnsupportedDocumentEncodingException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnsupportedDocumentEncodingException, __BaseException>);
}
/**
 * <p>The input for the GetRetainedMessage operation.</p>
 */
export interface GetRetainedMessageRequest {
    /**
     * <p>The topic name of the retained message to retrieve.</p>
     */
    topic: string | undefined;
}
export declare namespace GetRetainedMessageRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetRetainedMessageRequest) => any;
}
/**
 * <p>The output from the GetRetainedMessage operation.</p>
 */
export interface GetRetainedMessageResponse {
    /**
     * <p>The topic name to which the retained message was published.</p>
     */
    topic?: string;
    /**
     * <p>The Base64-encoded message payload of the retained message body.</p>
     */
    payload?: Uint8Array;
    /**
     * <p>The quality of service (QoS) level used to publish the retained message.</p>
     */
    qos?: number;
    /**
     * <p>The Epoch date and time, in milliseconds, when the retained message was stored by IoT.</p>
     */
    lastModifiedTime?: number;
}
export declare namespace GetRetainedMessageResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetRetainedMessageResponse) => any;
}
/**
 * <p>The input for the GetThingShadow operation.</p>
 */
export interface GetThingShadowRequest {
    /**
     * <p>The name of the thing.</p>
     */
    thingName: string | undefined;
    /**
     * <p>The name of the shadow.</p>
     */
    shadowName?: string;
}
export declare namespace GetThingShadowRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetThingShadowRequest) => any;
}
/**
 * <p>The output from the GetThingShadow operation.</p>
 */
export interface GetThingShadowResponse {
    /**
     * <p>The state information, in JSON format.</p>
     */
    payload?: Uint8Array;
}
export declare namespace GetThingShadowResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetThingShadowResponse) => any;
}
export interface ListNamedShadowsForThingRequest {
    /**
     * <p>The name of the thing.</p>
     */
    thingName: string | undefined;
    /**
     * <p>The token to retrieve the next set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The result page size.</p>
     */
    pageSize?: number;
}
export declare namespace ListNamedShadowsForThingRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListNamedShadowsForThingRequest) => any;
}
export interface ListNamedShadowsForThingResponse {
    /**
     * <p>The list of shadows for the specified thing.</p>
     */
    results?: string[];
    /**
     * <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
     */
    nextToken?: string;
    /**
     * <p>The Epoch date and time the response was generated by IoT.</p>
     */
    timestamp?: number;
}
export declare namespace ListNamedShadowsForThingResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListNamedShadowsForThingResponse) => any;
}
export interface ListRetainedMessagesRequest {
    /**
     * <p>To retrieve the next set of results, the <code>nextToken</code>
     *       value from a previous response; otherwise <b>null</b> to receive
     *       the first set of results.</p>
     */
    nextToken?: string;
    /**
     * <p>The maximum number of results to return at one time.</p>
     */
    maxResults?: number;
}
export declare namespace ListRetainedMessagesRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListRetainedMessagesRequest) => any;
}
/**
 * <p>Information about a single retained message.</p>
 */
export interface RetainedMessageSummary {
    /**
     * <p>The topic name to which the retained message was published.</p>
     */
    topic?: string;
    /**
     * <p>The size of the retained message's payload in bytes.</p>
     */
    payloadSize?: number;
    /**
     * <p>The quality of service (QoS) level used to publish the retained message.</p>
     */
    qos?: number;
    /**
     * <p>The Epoch date and time, in milliseconds, when the retained message was stored by IoT.</p>
     */
    lastModifiedTime?: number;
}
export declare namespace RetainedMessageSummary {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RetainedMessageSummary) => any;
}
export interface ListRetainedMessagesResponse {
    /**
     * <p>A summary list the account's retained messages. The information returned doesn't include
     *       the message payloads of the retained messages.</p>
     */
    retainedTopics?: RetainedMessageSummary[];
    /**
     * <p>The token for the next set of results, or null if there are no additional results.</p>
     */
    nextToken?: string;
}
export declare namespace ListRetainedMessagesResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListRetainedMessagesResponse) => any;
}
/**
 * <p>The input for the Publish operation.</p>
 */
export interface PublishRequest {
    /**
     * <p>The name of the MQTT topic.</p>
     */
    topic: string | undefined;
    /**
     * <p>The Quality of Service (QoS) level.</p>
     */
    qos?: number;
    /**
     * <p>A Boolean value that determines whether to set the RETAIN flag when the message is published.</p>
     *          <p>Setting the RETAIN flag causes the message to be retained and sent to new subscribers to the topic.</p>
     *          <p>Valid values: <code>true</code> | <code>false</code>
     *          </p>
     *          <p>Default value: <code>false</code>
     *          </p>
     */
    retain?: boolean;
    /**
     * <p>The message body. MQTT accepts text, binary, and empty (null) message payloads.</p>
     *          <p>Publishing an empty (null) payload with <b>retain</b> =
     *         <code>true</code> deletes the retained message identified by <b>topic</b> from Amazon Web Services IoT Core.</p>
     */
    payload?: Uint8Array;
}
export declare namespace PublishRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: PublishRequest) => any;
}
/**
 * <p>The payload exceeds the maximum size allowed.</p>
 */
export declare class RequestEntityTooLargeException extends __BaseException {
    readonly name: "RequestEntityTooLargeException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<RequestEntityTooLargeException, __BaseException>);
}
/**
 * <p>The input for the UpdateThingShadow operation.</p>
 */
export interface UpdateThingShadowRequest {
    /**
     * <p>The name of the thing.</p>
     */
    thingName: string | undefined;
    /**
     * <p>The name of the shadow.</p>
     */
    shadowName?: string;
    /**
     * <p>The state information, in JSON format.</p>
     */
    payload: Uint8Array | undefined;
}
export declare namespace UpdateThingShadowRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateThingShadowRequest) => any;
}
/**
 * <p>The output from the UpdateThingShadow operation.</p>
 */
export interface UpdateThingShadowResponse {
    /**
     * <p>The state information, in JSON format.</p>
     */
    payload?: Uint8Array;
}
export declare namespace UpdateThingShadowResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateThingShadowResponse) => any;
}
